//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////画图函数（IplImage）封装//////////////////////////////////////////////////////

//DIB位图显示						ShowImageOnClient()
//设置一个位图为其容器的中心		GetCenterRect()
//获得一个位图的信息头				CreateMapInfo()


#ifndef SELFUSE
#define SELFUSE 654321
#include "TouFile.h"

#ifdef OPENCV
/////////////////////////////获得客户区正中间的矩形区域///////////////////////////////////////////////////
void GetCenterRect(CRect rt,IplImage* image,CRect* rect)
{
	//CRect rt;
	//GetClientRect(hwnd,&rt);
	float a=MIN((float)rt.Width()/image->width,(float)rt.Height()/image->height);
	float width,height;
	width=image->width*a;
	height=image->height*a;
	rect->left=(rt.Width()-width)/2.;
	rect->top=(rt.Height()-height)/2.;
	rect->bottom=rect->top+height;
	rect->right=rect->left+width;
}

/*********************************************************************************************************/

//获得一幅位图（IplImage对象）的LPBITMAPINFO
RGBQUAD VgaDefPal[256] = {
	{0x00,0x00,0x00,0x00},{0xa8,0x00,0x00,0x00},{0x00,0xa8,0x00,0x00},{0xa8,0xa8,0x00,0x00},
	{0x00,0x00,0xa8,0x00},{0xa8,0x00,0xa8,0x00},{0x00,0x54,0xa8,0x00},{0xa8,0xa8,0xa8,0x00},
	{0x54,0x54,0x54,0x00},{0xfc,0x54,0x54,0x00},{0x54,0xfc,0x54,0x00},{0xfc,0xfc,0x54,0x00},
	{0x54,0x54,0xfc,0x00},{0xfc,0x54,0xfc,0x00},{0x54,0xfc,0xfc,0x00},{0xfc,0xfc,0xfc,0x00},
	{0x00,0x00,0x00,0x00},{0x14,0x14,0x14,0x00},{0x20,0x20,0x20,0x00},{0x2c,0x2c,0x2c,0x00},
	{0x38,0x38,0x38,0x00},{0x44,0x44,0x44,0x00},{0x50,0x50,0x50,0x00},{0x60,0x60,0x60,0x00},
	{0x70,0x70,0x70,0x00},{0x80,0x80,0x80,0x00},{0x90,0x90,0x90,0x00},{0xa0,0xa0,0xa0,0x00},
	{0xb4,0xb4,0xb4,0x00},{0xc8,0xc8,0xc8,0x00},{0xe0,0xe0,0xe0,0x00},{0xfc,0xfc,0xfc,0x00},
	{0xfc,0x00,0x00,0x00},{0xfc,0x00,0x40,0x00},{0xfc,0x00,0x7c,0x00},{0xfc,0x00,0xbc,0x00},
	{0xfc,0x00,0xfc,0x00},{0xbc,0x00,0xfc,0x00},{0x7c,0x00,0xfc,0x00},{0x40,0x00,0xfc,0x00},
	{0x00,0x00,0xfc,0x00},{0x00,0x40,0xfc,0x00},{0x00,0x7c,0xfc,0x00},{0x00,0xbc,0xfc,0x00},
	{0x00,0xfc,0xfc,0x00},{0x00,0xfc,0xbc,0x00},{0x00,0xfc,0x7c,0x00},{0x00,0xfc,0x40,0x00},
	{0x00,0xfc,0x00,0x00},{0x40,0xfc,0x00,0x00},{0x7c,0xfc,0x00,0x00},{0xbc,0xfc,0x00,0x00},
	{0xfc,0xfc,0x00,0x00},{0xfc,0xbc,0x00,0x00},{0xfc,0x7c,0x00,0x00},{0xfc,0x40,0x00,0x00},
	{0xfc,0x7c,0x7c,0x00},{0xfc,0x7c,0x9c,0x00},{0xfc,0x7c,0xbc,0x00},{0xfc,0x7c,0xdc,0x00},
	{0xfc,0x7c,0xfc,0x00},{0xdc,0x7c,0xfc,0x00},{0xbc,0x7c,0xfc,0x00},{0x9c,0x7c,0xfc,0x00},
	{0x7c,0x7c,0xfc,0x00},{0x7c,0x9c,0xfc,0x00},{0x7c,0xbc,0xfc,0x00},{0x7c,0xdc,0xfc,0x00},
	{0x7c,0xfc,0xfc,0x00},{0x7c,0xfc,0xdc,0x00},{0x7c,0xfc,0xbc,0x00},{0x7c,0xfc,0x9c,0x00},
	{0x7c,0xfc,0x7c,0x00},{0x9c,0xfc,0x7c,0x00},{0xbc,0xfc,0x7c,0x00},{0xdc,0xfc,0x7c,0x00},
	{0xfc,0xfc,0x7c,0x00},{0xfc,0xdc,0x7c,0x00},{0xfc,0xbc,0x7c,0x00},{0xfc,0x9c,0x7c,0x00},
	{0xfc,0xb4,0xb4,0x00},{0xfc,0xb4,0xc4,0x00},{0xfc,0xb4,0xd8,0x00},{0xfc,0xb4,0xe8,0x00},
	{0xfc,0xb4,0xfc,0x00},{0xe8,0xb4,0xfc,0x00},{0xd8,0xb4,0xfc,0x00},{0xc4,0xb4,0xfc,0x00},
	{0xb4,0xb4,0xfc,0x00},{0xb4,0xc4,0xfc,0x00},{0xb4,0xd8,0xfc,0x00},{0xb4,0xe8,0xfc,0x00},
	{0xb4,0xfc,0xfc,0x00},{0xb4,0xfc,0xe8,0x00},{0xb4,0xfc,0xd8,0x00},{0xb4,0xfc,0xc4,0x00},
	{0xb4,0xfc,0xb4,0x00},{0xc4,0xfc,0xb4,0x00},{0xd8,0xfc,0xb4,0x00},{0xe8,0xfc,0xb4,0x00},
	{0xfc,0xfc,0xb4,0x00},{0xfc,0xe8,0xb4,0x00},{0xfc,0xd8,0xb4,0x00},{0xfc,0xc4,0xb4,0x00},
	{0x70,0x00,0x00,0x00},{0x70,0x00,0x1c,0x00},{0x70,0x00,0x38,0x00},{0x70,0x00,0x54,0x00},
	{0x70,0x00,0x70,0x00},{0x54,0x00,0x70,0x00},{0x38,0x00,0x70,0x00},{0x1c,0x00,0x70,0x00},
	{0x00,0x00,0x70,0x00},{0x00,0x1c,0x70,0x00},{0x00,0x38,0x70,0x00},{0x00,0x54,0x70,0x00},
	{0x00,0x70,0x70,0x00},{0x00,0x70,0x54,0x00},{0x00,0x70,0x38,0x00},{0x00,0x70,0x1c,0x00},
	{0x00,0x70,0x00,0x00},{0x1c,0x70,0x00,0x00},{0x38,0x70,0x00,0x00},{0x54,0x70,0x00,0x00},
	{0x70,0x70,0x00,0x00},{0x70,0x54,0x00,0x00},{0x70,0x38,0x00,0x00},{0x70,0x1c,0x00,0x00},
	{0x70,0x38,0x38,0x00},{0x70,0x38,0x44,0x00},{0x70,0x38,0x54,0x00},{0x70,0x38,0x60,0x00},
	{0x70,0x38,0x70,0x00},{0x60,0x38,0x70,0x00},{0x54,0x38,0x70,0x00},{0x44,0x38,0x70,0x00},
	{0x38,0x38,0x70,0x00},{0x38,0x44,0x70,0x00},{0x38,0x54,0x70,0x00},{0x38,0x60,0x70,0x00},
	{0x38,0x70,0x70,0x00},{0x38,0x70,0x60,0x00},{0x38,0x70,0x54,0x00},{0x38,0x70,0x44,0x00},
	{0x38,0x70,0x38,0x00},{0x44,0x70,0x38,0x00},{0x54,0x70,0x38,0x00},{0x60,0x70,0x38,0x00},
	{0x70,0x70,0x38,0x00},{0x70,0x60,0x38,0x00},{0x70,0x54,0x38,0x00},{0x70,0x44,0x38,0x00},
	{0x70,0x50,0x50,0x00},{0x70,0x50,0x58,0x00},{0x70,0x50,0x60,0x00},{0x70,0x50,0x68,0x00},
	{0x70,0x50,0x70,0x00},{0x68,0x50,0x70,0x00},{0x60,0x50,0x70,0x00},{0x58,0x50,0x70,0x00},
	{0x50,0x50,0x70,0x00},{0x50,0x58,0x70,0x00},{0x50,0x60,0x70,0x00},{0x50,0x68,0x70,0x00},
	{0x50,0x70,0x70,0x00},{0x50,0x70,0x68,0x00},{0x50,0x70,0x60,0x00},{0x50,0x70,0x58,0x00},
	{0x50,0x70,0x50,0x00},{0x58,0x70,0x50,0x00},{0x60,0x70,0x50,0x00},{0x68,0x70,0x50,0x00},
	{0x70,0x70,0x50,0x00},{0x70,0x68,0x50,0x00},{0x70,0x60,0x50,0x00},{0x70,0x58,0x50,0x00},
	{0x40,0x00,0x00,0x00},{0x40,0x00,0x10,0x00},{0x40,0x00,0x20,0x00},{0x40,0x00,0x30,0x00},
	{0x40,0x00,0x40,0x00},{0x30,0x00,0x40,0x00},{0x20,0x00,0x40,0x00},{0x10,0x00,0x40,0x00},
	{0x00,0x00,0x40,0x00},{0x00,0x10,0x40,0x00},{0x00,0x20,0x40,0x00},{0x00,0x30,0x40,0x00},
	{0x00,0x40,0x40,0x00},{0x00,0x40,0x30,0x00},{0x00,0x40,0x20,0x00},{0x00,0x40,0x10,0x00},
	{0x00,0x40,0x00,0x00},{0x10,0x40,0x00,0x00},{0x20,0x40,0x00,0x00},{0x30,0x40,0x00,0x00},
	{0x40,0x40,0x00,0x00},{0x40,0x30,0x00,0x00},{0x40,0x20,0x00,0x00},{0x40,0x10,0x00,0x00},
	{0x40,0x20,0x20,0x00},{0x40,0x20,0x28,0x00},{0x40,0x20,0x30,0x00},{0x40,0x20,0x38,0x00},
	{0x40,0x20,0x40,0x00},{0x38,0x20,0x40,0x00},{0x30,0x20,0x40,0x00},{0x28,0x20,0x40,0x00},
	{0x20,0x20,0x40,0x00},{0x20,0x28,0x40,0x00},{0x20,0x30,0x40,0x00},{0x20,0x38,0x40,0x00},
	{0x20,0x40,0x40,0x00},{0x20,0x40,0x38,0x00},{0x20,0x40,0x30,0x00},{0x20,0x40,0x28,0x00},
	{0x20,0x40,0x20,0x00},{0x28,0x40,0x20,0x00},{0x30,0x40,0x20,0x00},{0x38,0x40,0x20,0x00},
	{0x40,0x40,0x20,0x00},{0x40,0x38,0x20,0x00},{0x40,0x30,0x20,0x00},{0x40,0x28,0x20,0x00},
	{0x40,0x2c,0x2c,0x00},{0x40,0x2c,0x30,0x00},{0x40,0x2c,0x34,0x00},{0x40,0x2c,0x3c,0x00},
	{0x40,0x2c,0x40,0x00},{0x3c,0x2c,0x40,0x00},{0x34,0x2c,0x40,0x00},{0x30,0x2c,0x40,0x00},
	{0x2c,0x2c,0x40,0x00},{0x2c,0x30,0x40,0x00},{0x2c,0x34,0x40,0x00},{0x2c,0x3c,0x40,0x00},
	{0x2c,0x40,0x40,0x00},{0x2c,0x40,0x3c,0x00},{0x2c,0x40,0x34,0x00},{0x2c,0x40,0x30,0x00},
	{0x2c,0x40,0x2c,0x00},{0x30,0x40,0x2c,0x00},{0x34,0x40,0x2c,0x00},{0x3c,0x40,0x2c,0x00},
	{0x40,0x40,0x2c,0x00},{0x40,0x3c,0x2c,0x00},{0x40,0x34,0x2c,0x00},{0x40,0x30,0x2c,0x00},
	{0xa8,0xa8,0xa8,0x00},{0x54,0xfc,0xfc,0x00},{0xfc,0x54,0xfc,0x00},{0xfc,0xfc,0x54,0x00},
	{0xfc,0x54,0x54,0x00},{0x54,0xfc,0x54,0x00},{0x54,0x54,0xfc,0x00},{0xfc,0xfc,0xfc,0x00}  
};

RGBQUAD  VgaColorTab[256];
/*********************************************************************************************************/

LPBITMAPINFO CtreateMapInfo(IplImage* workImg,int flag)
{                                           //  建立位图信息
	BITMAPINFOHEADER BIH={40,1,1,1,8,0,0,0,0,0,0};
	LPBITMAPINFO lpBmi;
	int      wid,hei,bits,colors,i;

	wid =workImg->width;
	hei =workImg->height;
	bits=workImg->depth*workImg->nChannels;

	if (bits>8) 
		colors=0;
	else 
		colors=1<<bits;

	lpBmi=(LPBITMAPINFO) malloc(40+4*colors);
	BIH.biWidth   =wid;
	BIH.biHeight  =-hei;						//为正值时图像的原点在右下角，负值时在左上角
	BIH.biBitCount=(BYTE) bits;
	memcpy(lpBmi,&BIH,40);                  //  复制位图信息头

	if (bits==8) {                          //  256 色位图
		if (flag==1) {                      //  设置灰阶调色板
			for (i=0;i<256;i++) 
			{
				VgaColorTab[i].rgbRed=VgaColorTab[i].rgbGreen=
					VgaColorTab[i].rgbBlue=(BYTE) i;
			}
			memcpy(lpBmi->bmiColors,VgaColorTab,1024);
		}
		else if (flag==2) 
		{                 //  设置默认调色板
			memcpy(lpBmi->bmiColors,VgaDefPal,1024);
		}
		else if (flag==3) {                 //  设置自定义调色板
			memcpy(lpBmi->bmiColors,VgaColorTab,1024);
		}
	}
	return(lpBmi);
}

/*********************************************************************************************************/

//DIB位图显示		
void ShowImageOnClient(HDC pDC, IplImage* image, CRect rect,int flags=1)
{
	char* imagedata=image->imageData;
	LPBITMAPINFO lpbitm;
	lpbitm=CtreateMapInfo(image,flags);
	StretchDIBits(pDC,
		rect.left,rect.top,rect.Width(),rect.Height(),
		0,0,image->width,image->height,
		imagedata,lpbitm,DIB_RGB_COLORS,SRCCOPY);
}
#endif //OPENCV


/*********************************************************************************************************/




/*///////////////////////////////////////////////////////////////////////////////////////
先创建一个JIANTING的对象存放窗口句柄，然后创建一个线程（此线程应该为一个类的成员变量，
								不能是局部变量），线程的函数为SpeakRecognitionJianTing。
	JIANTING * a=new JIANTIN;
	a->hWnd=m_hWnd;
	HANDLE xiancheng=CreateThread(NULL,0,SpeakRecognitionJianTing,(LPVOID)a,0,NULL);
	CloseHandle(xiancheng);

//////////////////////////////////////////////////////////////////////////////////////*/
//以下代码来源于C:\Program Files\Microsoft Speech SDK 5.1\Samples\CPP\TalkBack
#ifdef SpeechSDK 
#include"sapi.h"
#include "sphelper.h"
#define ID_DICTIONARY                   101

struct JIANTING
{
	HWND hWnd;
	CString yufaku;
	UINT Msg;
};

inline HRESULT BlockForResult(ISpRecoContext * pRecoCtxt , ISpRecoResult ** ppResult)//识别上下文把听到的数据存于识别结果（ppResult）中
{
	HRESULT hr = S_OK;
	CSpEvent event;
	
	while (SUCCEEDED(hr) &&
		SUCCEEDED(hr = event.GetFrom(pRecoCtxt)) &&
		hr == S_FALSE)
	{
		hr = pRecoCtxt->WaitForNotifyEvent(INFINITE);
	}
	
	*ppResult = event.RecoResult();
	if (*ppResult)
	{
		(*ppResult)->AddRef();
	}
	return hr;
}
									/*StopWord函数的具体作用还不清楚*/
// const WCHAR *CStudyDlg:: StopWord()
// {
// 	const WCHAR * pchStop;
// 	
// 	LANGID LangId = ::SpGetUserDefaultUILanguage();
// 	switch (LangId)
// 	{
// 	case MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT):
// 		pchStop = L"\x7d42\x4e86\\\x30b7\x30e5\x30fc\x30ea\x30e7\x30fc/\x3057\x3085\x3046\x308a\x3087\x3046";;
// 		break;
// 		
// 	default:
// 		pchStop = L"Stop";
// 		break;
// 	}
// 	
// 	return pchStop;
// }



inline DWORD WINAPI SRJianTing(LPVOID a)											//实现语音识别的监听，监听到数据后发送消息至指定窗口
{
	HWND hWnd=((JIANTING*)a)->hWnd;
	CString yufaku=((JIANTING*)a)->yufaku;
	UINT Msg=((JIANTING*)a)->Msg;
	HRESULT hr = E_FAIL;

	CString xml=yufaku.Right(3);
	bool flag_yufa;
	xml.MakeLower();
	if(xml!="xml")
	{
		flag_yufa=false;
	}
	else
	{
		flag_yufa=true;
	}


	if (SUCCEEDED(hr = ::CoInitialize(NULL)))														//初始化COM口
	{
		{
			CComPtr<ISpRecoContext> cpRecoCtxt;
			CComPtr<ISpRecoGrammar> cpGrammar;
			/*CComPtr<ISpVoice> cpVoice;*/
			hr = cpRecoCtxt.CoCreateInstance(CLSID_SpSharedRecoContext);
// 			if(SUCCEEDED(hr))
// 			{
// 				hr = cpRecoCtxt->GetVoice(&cpVoice);
// 			}
			//语法库加载前准备
			WCHAR wszXMLFile[100]=L"";
			MultiByteToWideChar(CP_ACP, 0, (LPCSTR)yufaku, -1, wszXMLFile, 256);					//ANSI转UNINCODE

			if (cpRecoCtxt /*&& cpVoice*/ &&
				SUCCEEDED(hr = cpRecoCtxt->SetNotifyWin32Event()) &&
                SUCCEEDED(hr = cpRecoCtxt->SetInterest(SPFEI(SPEI_RECOGNITION), SPFEI(SPEI_RECOGNITION))) &&//设置感兴趣事件
                SUCCEEDED(hr = cpRecoCtxt->SetAudioOptions(SPAO_RETAIN_AUDIO, NULL, NULL)))
			{
				
				if (flag_yufa)
				{
					
					if(	FAILED(hr = cpRecoCtxt->CreateGrammar(ID_DICTIONARY, &cpGrammar)) ||	//创建语法规则为使用命令语法库
						FAILED(hr = cpGrammar->LoadCmdFromFile(wszXMLFile,SPLO_DYNAMIC)))		//加载语法库
					{
						::CoUninitialize();
						AfxMessageBox("加载命令语法库失败！");
						return 0;
					}
				}
				/*	const WCHAR * const pchStop = StopWord();*/
				else
				{
					if(	FAILED(hr = cpRecoCtxt->CreateGrammar(0, &cpGrammar)) ||				//创建语法规则为使用命令语法库
						FAILED(hr = cpGrammar->LoadDictation(NULL, SPLO_STATIC)) )				//加载语法库
					{
						::CoUninitialize();
						AfxMessageBox("加载通用语法库失败！");
						return 0;
					}
				}

				if(	FAILED(hr = cpGrammar->SetDictationState(SPRS_ACTIVE))||					//激活语法库
					FAILED(hr = cpGrammar->SetRuleState( NULL,NULL,SPRS_ACTIVE )))				
				{
					::CoUninitialize();
					return 0;
				}
				USES_CONVERSION;																//用于编码转换（比如CString到LPCWSTR）
				CComPtr<ISpRecoResult> cpResult;
				
				//开始聆听
				while (SUCCEEDED(hr = BlockForResult(cpRecoCtxt, &cpResult)))
				{
					cpGrammar->SetDictationState(SPRS_INACTIVE);								//聆听到数据后使语法库失效
					
					CSpDynamicString dstrText;
					
					CString str1="";
					CString str2="";
					CString a="";
					CString b="";
					CString c="";
					//把听到的数据存入dstrText
					if (SUCCEEDED(cpResult->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, 
						TRUE, &dstrText, NULL)))
					{
						
						CString tingdata=(CString)dstrText;
						
						::SendMessage(hWnd,Msg,(WPARAM)&tingdata,NULL);							//听到数据后，发送消息（包含听到的数据）
																								//至指定的窗口处理
						cpResult.Release();
					}
					cpGrammar->SetDictationState(SPRS_ACTIVE);									//重新激活语法库
				} 
			}
		}
		::CoUninitialize();
	}
	return 0;
}
inline void CreateSRThread(HANDLE& xiancheng,LPVOID info,LPTHREAD_START_ROUTINE thread=SRJianTing)
{
	xiancheng=CreateThread(NULL,0,thread,(LPVOID)info,0,NULL);
	CloseHandle(xiancheng);
}
inline void FileRead(CFile& file,CString& str)
{
	HLOCAL hMem;
	char* pbyte;
	LONG len;
	len=file.GetLength();
	hMem=LocalAlloc(LHND,len+1);
	if(hMem==NULL)
	{
		AfxMessageBox("内存分配失败！");
		return ;
	}
	pbyte=(char*)LocalLock(hMem);
	memset(pbyte,0,len+1);
	file.ReadHuge(pbyte,len);
	str=pbyte;
	LocalUnlock(pbyte);
	LocalFree(hMem);
}
inline void WriteXML(CString path,CString goods)
{
	CFile file;
	if(!file.Open(path,CFile::modeRead))
	{
		AfxMessageBox("文件打开失败！");
		return;
	}
	CString str;

	FileRead(file,str);
	
	int end;
	int len=str.GetLength();
	end=str.Find("</DEFINE>",0);
	CString str_left=str.Left(end);
	//MessageBox(str_left);
	CString str_right=str.Right(len-end);
	//MessageBox(str_right);
	CString ID1="   <ID NAME=\"CMD_";
	CString ID2="";
	CString ID3="\" VAL=\"";
	CString ID4="";
	CString ID5="\" />\r\n";
	
	int sel=-3;
	int e;
	while(sel!=-1)
	{
		e=sel;
		sel=str.Find("<ID",sel=sel+3);
	}
	
	CString last_str=str.Mid(e,end-e);
	//MessageBox(last_str);
	int i;
	CString int1="";
	CString int2="";
	int k=last_str.Find("VAL",0);
	for(i=0;i<k;i++)
	{
		CString s=last_str.Mid(i,1);
		if (s>=48&&s<=57)
		{
			int1+=s;
		}
	}
	for(i=k;i<last_str.GetLength();i++)
	{
		CString s=last_str.Mid(i,1);
		if (s>=48&&s<=57)
		{
			int2+=s;
		}
	}
	int a1=atoi(int1.GetBuffer(int1.GetLength()));
	int a2=atoi(int2.GetBuffer(int2.GetLength()));
	a1++;
	a2++;
	ID2.Format("%d",a1);
	ID4.Format("%d",a2);
	//CString addID="   <ID NAME=\"CMD_10004\" VAL=\"10004\" />\r\n";
	CString addID;
	addID=ID1+ID2+ID3+ID4+ID5;
	//MessageBox(addID);
	str=str_left+addID+str_right;
	
	int end2;
	int len2=str.GetLength();
	end2=str.Find("</GRAMMAR>",0);
	CString str_left2=str.Left(end2);
	//MessageBox(str_left2);
	CString str_right2=str.Right(len2-end2);
	//MessageBox(str_right2);
	//CString addOrder="<RULE ID=\"CMD_10005\" TOPLEVEL=\"ACTIVE\">\r\n<PHRASE>李智博</PHRASE>\r\n</RULE>\r\n";
	CString order1="<RULE ID=\"CMD_";
	CString order2=ID2;
	CString order3="\" TOPLEVEL=\"ACTIVE\">\r\n<PHRASE>";
	CString order4=goods;
	CString order5="</PHRASE>\r\n</RULE>\r\n";
	CString addOrder=order1+order2+order3+order4+order5;
	//MessageBox(addOrder);
	str=str_left2+addOrder+str_right2;
	
	//MessageBox(str);
	
	file.Close();
	if(!file.Open(path,CFile::modeWrite))
	{
		AfxMessageBox("写入文件失败！");
	}
	file.Write(str,str.GetLength());
}
#endif//SpeakSDK
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
#endif